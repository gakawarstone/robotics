#pragma config(Sensor, S1,     ,               sensorLightActive)
#pragma config(Sensor, S2,     ,               sensorLightActive)
#pragma config(Sensor, S4,     ,               sensorSONAR)
#pragma config(Motor,  motorA,           ,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
////////////////////////////////
  nxtDisplayCenteredTextLine(3, "linia");
  nxtDisplayCenteredTextLine(4, "i am winer:)");
	int sonar = 20;
	bool skittle_1 = false;
	float k1= 1.5, //koeficent povorotlivosti                              /*variables*/
				k2=30,  // yskorenie
				kv= 1;   //koeficent tormoghenia
	int 	vmax=50;
	////////////////////////////////
	int es=SensorValue[S1]-SensorValue[S2];
	int v , u ,err , errold=0, mB, mC;
	int greay  = 40;



	nMotorEncoder[motorA] = 0;
  nMotorEncoder[motorB] = 0;

  while(nMotorEncoder[motorB] <= 500)//go back
  {
  	motor[motorB] = 50;
  	motor[motorC] = 50;
	}

	while (skittle_1 != true)//black line
	{
		if(SensorValue[S4] > sonar)
		{
			err=SensorValue[S1]-SensorValue[S2]-es;
			u=k1*err+k2*(err-errold);
			errold=err;
			v=vmax-abs(u)*kv;
			mB=v+u;
			mC=v-u;
			if (abs(mB)>100) mB=sgn(mB)*100;
			if (abs(mC)>100) mB=sgn(mC)*100;
			motor[motorB]=mB;
			motor[motorC]=mC;
			wait1Msec(1);
		}

		else
		{
			nMotorEncoder[motorB] = 0;

			while(nMotorEncoder[motorB] <= 100) //turn to skittle
			{
				motor[motorB] = 40;
				motor[motorC] = 40;
			}

			motor[motorB] = 0;
			motor[motorC] = 0;


			while(true)//first claw turn to 90 degrees
			{
				if(nMotorEncoder[motorA] < 60)
				{
					motor[motorA] = 50;
					wait1Msec(1);
				}

				else break;
			}

			while(nMotorEncoder[motorA] > 0)//close claw
			{
				motor[motorA] = -100;
				wait1Msec(1);
			}

			motor[motorA] = 0;

			nMotorEncoder[motorB] = 0;

			while(nMotorEncoder[motorB] >= -20)//go to the back a litle
			{
				motor[motorB] = -50;
				motor[motorC] = -50;
				wait1Msec(1);
			}


			nMotorEncoder[motorB] = 0;

			while(nMotorEncoder[motorB] <= 680)//turn to 90 degrees
			{
				motor[motorB] = 50;
				motor[motorC] = 0;
			}

			motor[motorB] = 0;


			skittle_1 = true;
		}
	}

	skittle_1 = false;


	while (skittle_1 != true)//go for black line
	{
		if(SensorValue[S4] > sonar)
		{
			err=SensorValue[S1]-SensorValue[S2]-es;
			u=k1*err+k2*(err-errold);
			errold=err;
			v=vmax-abs(u)*kv;
			mB=v+u;
			mC=v-u;
			if (abs(mB)>100) mB=sgn(mB)*100;
			if (abs(mC)>100) mB=sgn(mC)*100;
			motor[motorB]=mB;
			motor[motorC]=mC;
			wait1Msec(1);
		}

		else
		{
			nMotorEncoder[motorB] = 0;

			while(nMotorEncoder[motorB] >= -10)//go to the back a little
			{
				motor[motorB] = -50;
				motor[motorC] = -50;
				wait1Msec(1);
			}

			while(true)//claw turn to 90 degrees
			{
				if(nMotorEncoder[motorA] < 60)
				{
					motor[motorA] = 50;
					wait1Msec(1);
				}

				else break;
			}

			motor[motorA] = 0;

			nMotorEncoder[motorB] = 0;

			while(nMotorEncoder[motorB] <= 300) //turn to first skittle
			{
				motor[motorB] = 40;
				motor[motorC] = 40;
			}

			motor[motorB] = 0;
			motor[motorC] = 0;


			while(nMotorEncoder[motorA] > 0)//close claw
			{
				motor[motorA] = -100;
				wait1Msec(1);
			}

			motor[motorA] = 0;
			wait1Msec(500);


			while(true)//claw turn to 90 degrees
			{
				if(nMotorEncoder[motorA] < 60)
				{
					motor[motorA] = 50;
					wait1Msec(1);
				}

				else break;
			}

			motor[motorA] = 0;//stop

			motor[motorB] = 0;//stop
			motor[motorC] = 0;//stop


			nMotorEncoder[motorC] = 0;

			while(nMotorEncoder[motorC] < 420)// turn to 180 degrees
			{
				motor[motorB] = -50;
				motor[motorC] = 50;
				wait1Msec(1);
			}

			motor[motorB] = 0;
			motor[motorC] = 0;


			while(nMotorEncoder[motorA] > 0)// close claw
			{
				motor[motorA] = -100;
				wait1Msec(1);
			}

			motor[motorA] = 0;

			nMotorEncoder[motorB] = 0;

			while(nMotorEncoder[motorB] >= -2000)// back to the start
			{
				motor[motorB] = -50;
				motor[motorC] = -50;
				wait1Msec(1);
			}

			motor[motorB] = 0;
			motor[motorC] = 0;


			skittle_1 = true;

		}
	}
}
