#pragma config(Sensor, S1,     ,               sensorLightActive)
#pragma config(Sensor, S2,     ,               sensorLightActive)
#pragma config(Sensor, S4,     ,               sensorSONAR)
#pragma config(Motor,  motorA,           ,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	////////////////////////////////
  nxtDisplayCenteredTextLine(3, "linia");
  nxtDisplayCenteredTextLine(4, "i am winer:)");
	float k1= 1.85, //koeficent povorotlivosti
				k2=30,  // yskorenie
				kv= 1.2;   //koeficent tormoghenia
	int 	vmax=50;
	////////////////////////////////
	int es=SensorValue[S1]-SensorValue[S2];
	int v , u ,err , errold=0, mB, mC;
	int greay  = 40;
	int sonar = 20;
	bool skittle_1 = false;

	nMotorEncoder[motorA] = 0;

	while (skittle_1 == false)
	{
		if(SensorValue[S4] > sonar)
		{
			err=SensorValue[S1]-SensorValue[S2]-es;
			u=k1*err+k2*(err-errold);
			errold=err;
			v=vmax-abs(u)*kv;
			mB=v+u;
			mC=v-u;
			if (abs(mB)>100) mB=sgn(mB)*100;
			if (abs(mC)>100) mB=sgn(mC)*100;
			motor[motorB]=mB;
			motor[motorC]=mC;

			//if(SensorValue[l1] && SensorValue[l2] <= greay)
			wait1Msec(1);
		}

		else
		{
			while(nMotorEncoder[motorB] <= 270) //turn to first skittle
			{
				motor[motorB] = 40;
				motor[motorC] = 40;
			}

			motor[motorB] = 0;
			motor[motorC] = 0;

			nMotorEncoder[motorC]  = 0;


			while(nMotorEncoder[motorC] <= 170)
			{
				motor[motorC] = 50;
			}

			motor[motorC]  = 0;




			while(true)//first claw turn to 90 degrees
			{
				if(nMotorEncoder[motorA] < 160)
				{
					motor[motorA] = 50;
					wait1Msec(1);
				}

				else break;
			}


			skittle_1 = true;
		}
	}
}
