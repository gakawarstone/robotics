#pragma config(Sensor, S1,     ,               sensorSONAR)
#pragma config(Sensor, S2,     ,               sensorEV3_Color)
#pragma config(Sensor, S3,     ,               sensorLightActive)
#pragma config(Sensor, S4,     ,               sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include <"functions.h">
volatile int color;
volatile int encoder_b;
volatile int encoder_b_2;
volatile int greay = 30;
volatile int skittle_greay = 9;
volatile int counter_1;

task display()
{
	while(true)
	{
		DisplayBigStringAt(30,100,"%d",SensorValue[S1]);
		displayBigStringAt(30,30,"%d",color);
		displayBigStringAt(10,10,"%d",SensorValue[S2]);
	}
}

void search()
{
	nMotorEncoder[motorB] = 0;
	color = 0;

	while(SensorValue[S1] >= 40)
	{
		motor[motorB] = 30;
		motor[motorC] = -30;
	}

	nMotorEncoder[motorB] = 0;

	while(nMotorEncoder[motorB] >= -10)
	{
		motor[motorB] = -30;
		motor[motorC] = 30;
	}

	while(nMotorEncoder[motorB] <= 23)
	{
		motor[motorB] = 30;
		motor[motorC] = -30;
	}

	motor[motorB] = 0;
	motor[motorC] = 0;
}

void begin()
{
	startTask(display);
	struct skittle{bool skittle_color};
}

void end()
{
	motor[motorB] = 0;
	motor[motorC] = 0;
	wait1Msec(5000);
	stopTask(display);
}

void turn_to_skittle()
{

	/*while(SensorValue[S2] == 0)
	{
		motor[motorB] = 30;
		motor[motorC] = 30;
	}*/

	encoder_b = nMotorEncoder[motorB];
	nMotorEncoder[motorB] = 0;

	while(nMotorEncoder[motorB] <= 600)
	{
		motor[motorB] = 30;
		motor[motorC] = 30;
	}

	nMotorEncoder[motorB] = 0;

		while(nMotorEncoder[motorB] >= -10)
	{
		motor[motorB] = -30;
		motor[motorC] = 30;
	}

	while(nMotorEncoder[motorB] <= 23)
	{
		motor[motorB] = 30;
		motor[motorC] = -30;
	}
}


void check_skittle()
{
	motor[motorB] = 0;
	motor[motorC] = 0;
	wait1Msec(500);

	while(true)
	{
		if(SensorValue[S2] >= greay) color = 6;
		else if(SensorValue[S2] <= greay) color = 1;
		if(color == 1) break;
		if(color == 6) break;
		/*{
			while(SensorValue[S3] > 40 && SensorValue[S4] < 40)
			{
				motor[motorB] = 30;
				motor[motorC] = 30;
			}
		}*/
	}
}

void black_skittle()
{
	while(nMotorEncoder[motorB] + encoder_b >= 0)
	{
		motor[motorB] = -30;
		motor[motorC] = -30;
	}

	while(nMotorEncoder[motorB] + encoder_b <= 23)
	{
		motor[motorB] = 30;
		motor[motorC] = -30;
	}
}

void white_skittle()
{
	while(SensorValue[S3] >= greay && SensorValue[S4] >= greay)
	{
		motor[motorB] = 30;
		motor[motorC] = 30;
	}

	encoder_b_2 = nMotorEncoder[motorB];

	while(nMotorEncoder[motorB] < encoder_b_2 + 30)
	{
		motor[motorB] = 100;
		motor[motorC] = 150;
	}

	while(nMotorEncoder[motorB] + encoder_b >= 0)
	{
		motor[motorB] = -30;
		motor[motorC] = -30;
	}
}

task main()
{
	begin();
		search();
		turn_to_skittle();
		check_skittle();
		if(color == 6) white_skittle();
		if(color == 1) black_skittle();
	//if(color == 6) struct skittle first = {true};
	//if(color == 1) first skittle(false);
	setLEDColor(ledRedPulse);
	end();
}
