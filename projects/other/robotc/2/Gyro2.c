#pragma config(Sensor, S2,     Ls,             sensorEV3_Color)
#pragma config(Sensor, S3,     Gs,             sensorEV3_Gyro)
#pragma config(Motor,  motorB,          mB,            tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          mC,            tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
/*void kalibrovka(){
	int Gyro=SensorValue[Gs];
	//wait1Msec(2000);
	playSound(soundBeepBeep);
		displayBigTextLine(2,"%d", SensorValue[Gs]);
wait1Msec(3000);
}*/
#define WAIT_TIME    8.0
#define KGYROANGLE  7.5
#define KGYROSPEED  1.15
#define KPOS        0.14
#define KSPEED      0.2
#define OFFSET_SAMPLES 100
#define EMAOFFSET 0.0005
task main()
{
//kalibrovka();

float err, errold=0;
float kp=20, kd=0, ki=0, u, dt=0;
float up, ud, ui=0;
float scale=1;
  int GyroSensor = getGyroRate(Gs);
     float tInterval = WAIT_TIME*0.001;
     float ratioWheel = 1.4;
     float gOffset;
     float gAngleGlobal = 0;
     long mrcAver = 0, mrcAverPrev;
     float gyroSpeed, gyroAngle;
     float motorSpeed;
     int power, powerLeft, powerRight;
     float gSum, GyroRaw;
     int  i, gMin, gMax, g;
     long mrcLeft, mrcRight;

     wait1Msec(50);
     do {
        gSum = 0.0;
        gMin = -1000;
        gMax = 1000;
        for (i=0; i<OFFSET_SAMPLES; i++) {
            g =   getGyroRate(Gs);

            if (g > gMax)
               gMax = g;
            if (g < gMin)
               gMin = g;
            gSum += g;
            wait1Msec(5);
            }
        } while ((gMax - gMin) > 1);
        gOffset = gSum / OFFSET_SAMPLES;
        displayBigTextLine(4, "Balance in 3 seconds");
       // nxtDisplayTextLine(4,"Balance in 3 second");

        wait1Msec(3000);
        playTone(440,100);
        eraseDisplay();
	//resetGyro(Gs);
//	int Gyro=getGyroRate(Gs);
//	playSound(soundBeepBeep);
		//displayBigTextLine(2,"%d", getGyroRate(Gs));
//wait1Msec(3000);

while (true)
{
  GyroRaw = getGyroRate(Gs);
            gOffset = EMAOFFSET * GyroRaw + (1-EMAOFFSET) * gOffset;
            gyroSpeed = GyroRaw - gOffset;
	err=gyroSpeed;
	up=kp*err;
	ui=ui+ki*err*dt;
	ud=kd*errold;
	errold=err;
	u=(up+ud+ui)/scale;
	motor[mB]=u;
	motor[mC]=u;
	wait1Msec(1);
			displayBigTextLine(2,"%d", getGyroRate(Gs));


}
}
